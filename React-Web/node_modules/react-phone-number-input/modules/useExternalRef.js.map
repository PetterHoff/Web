{"version":3,"file":"useExternalRef.js","names":["useRef","useCallback","useExternalRef","externalRef","refCopy","refSetter","value","setRefsValue","refs","_iterator","_createForOfIteratorHelperLoose","_step","done","ref","setRefValue","current"],"sources":["../source/useExternalRef.js"],"sourcesContent":["import { useRef, useCallback } from 'react'\r\n\r\n/**\r\n * This hook creates an internal copy of a `ref`\r\n * and returns a new `ref`-alike setter function\r\n * that updates both `ref` and the internal copy of it.\r\n * That `ref`-alike setter function could then be passed\r\n * to child elements instead of the original `ref`.\r\n *\r\n * The internal copy of the `ref` can then be used to\r\n * call instance methods like `.focus()`, etc.\r\n *\r\n * One may ask: why create a copy of `ref` for \"internal\" use\r\n * when the code could use the original `ref` for that.\r\n * The answer is: the code would have to dance around the original `ref` anyway\r\n * to figure out whether it exists and to find out the internal implementation of it\r\n * in order to read its value correctly. This hook encapsulates all that \"boilerplate\" code.\r\n * The returned copy of the `ref` is guaranteed to exist and functions as a proper ref \"object\".\r\n * The returned `ref`-alike setter function must be used instead of the original `ref`\r\n * when passing it to child elements.\r\n *\r\n * @param  {(object|function)} [externalRef] â€” The original `ref` that may have any internal implementation and might not even exist.\r\n * @return {any[]} Returns an array of two elements: a copy of the `ref` for \"internal\" use and a `ref`-alike setter function that should be used in-place of the original `ref` when passing it to child elements.\r\n */\r\nexport default function useExternalRef(externalRef) {\r\n  // Create a copy of the original `ref` (which might not exist).\r\n  // Both refs will point to the same value.\r\n  const refCopy = useRef()\r\n\r\n  // Updates both `ref`s with the same `value`.\r\n  const refSetter = useCallback((value) => {\r\n    setRefsValue([externalRef, refCopy], value)\r\n  }, [\r\n    externalRef,\r\n    refCopy\r\n  ])\r\n\r\n  return [refCopy, refSetter]\r\n}\r\n\r\n// Sets the same `value` of all `ref`s.\r\n// Some of the `ref`s may not exist in which case they'll be skipped.\r\nexport function setRefsValue(refs, value) {\r\n  for (const ref of refs) {\r\n    if (ref) {\r\n      setRefValue(ref, value)\r\n    }\r\n  }\r\n}\r\n\r\n// Sets the value of a `ref`.\r\n// Before React Hooks were introduced, `ref`s used to be functions.\r\n// After React Hooks were introduces, `ref`s became objects with `.current` property.\r\n// This function sets a `ref`'s value regardless of its internal implementation,\r\n// so it supports both types of `ref`s.\r\nfunction setRefValue(ref, value) {\r\n  if (typeof ref === 'function') {\r\n    ref(value)\r\n  } else {\r\n    ref.current = value\r\n  }\r\n}"],"mappings":";;;AAAA,SAASA,MAAM,EAAEC,WAAW,QAAQ,OAAO;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,cAAcA,CAACC,WAAW,EAAE;EAClD;EACA;EACA,IAAMC,OAAO,GAAGJ,MAAM,CAAC,CAAC;;EAExB;EACA,IAAMK,SAAS,GAAGJ,WAAW,CAAC,UAACK,KAAK,EAAK;IACvCC,YAAY,CAAC,CAACJ,WAAW,EAAEC,OAAO,CAAC,EAAEE,KAAK,CAAC;EAC7C,CAAC,EAAE,CACDH,WAAW,EACXC,OAAO,CACR,CAAC;EAEF,OAAO,CAACA,OAAO,EAAEC,SAAS,CAAC;AAC7B;;AAEA;AACA;AACA,OAAO,SAASE,YAAYA,CAACC,IAAI,EAAEF,KAAK,EAAE;EACxC,SAAAG,SAAA,GAAAC,+BAAA,CAAkBF,IAAI,GAAAG,KAAA,IAAAA,KAAA,GAAAF,SAAA,IAAAG,IAAA,GAAE;IAAA,IAAbC,GAAG,GAAAF,KAAA,CAAAL,KAAA;IACZ,IAAIO,GAAG,EAAE;MACPC,WAAW,CAACD,GAAG,EAAEP,KAAK,CAAC;IACzB;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASQ,WAAWA,CAACD,GAAG,EAAEP,KAAK,EAAE;EAC/B,IAAI,OAAOO,GAAG,KAAK,UAAU,EAAE;IAC7BA,GAAG,CAACP,KAAK,CAAC;EACZ,CAAC,MAAM;IACLO,GAAG,CAACE,OAAO,GAAGT,KAAK;EACrB;AACF","ignoreList":[]}